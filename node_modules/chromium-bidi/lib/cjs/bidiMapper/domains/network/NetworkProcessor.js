"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkProcessor = void 0;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const protocol_js_1 = require("../../../protocol/protocol.js");
const NetworkStorage_js_1 = require("./NetworkStorage.js");
/** Dispatches Network domain commands. */
class NetworkProcessor {
    #browsingContextStorage;
    #networkStorage;
    constructor(browsingContextStorage, networkStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#networkStorage = networkStorage;
    }
    async addIntercept(params) {
        if (params.phases.length === 0) {
            throw new protocol_js_1.InvalidArgumentException('At least one phase must be specified.');
        }
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = NetworkProcessor.parseUrlPatterns(urlPatterns);
        const intercept = this.#networkStorage.addIntercept({
            urlPatterns: parsedUrlPatterns,
            phases: params.phases,
        });
        // TODO: Add try/catch. Remove the intercept if CDP Fetch commands fail.
        await this.#applyIntercepts();
        return {
            intercept,
        };
    }
    continueRequest(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    continueResponse(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    continueWithAuth(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    failRequest(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    provideResponse(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    async removeIntercept(params) {
        this.#networkStorage.removeIntercept(params.intercept);
        // TODO: Add try/catch. Remove the intercept if CDP Fetch commands fail.
        await this.#applyIntercepts();
        return {};
    }
    /** Applies all existing network intercepts to all CDP targets concurrently. */
    async #applyIntercepts() {
        await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            await context.cdpTarget.fetchApply();
        }));
    }
    static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
            switch (urlPattern.type) {
                case 'string': {
                    try {
                        new URL(urlPattern.pattern);
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${urlPattern.pattern}': ${error}`);
                    }
                    return urlPattern;
                }
                case 'pattern':
                    if (urlPattern.protocol === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a protocol`);
                    }
                    if (urlPattern.hostname === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a hostname`);
                    }
                    if ((urlPattern.hostname?.length ?? 0) > 0) {
                        if (urlPattern.protocol?.match(/^file/i)) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                        }
                        if (urlPattern.hostname?.includes(':')) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern hostname must not contain a colon`);
                        }
                    }
                    if (urlPattern.port === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                    }
                    try {
                        new URL(NetworkStorage_js_1.NetworkStorage.buildUrlPatternString(urlPattern));
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`${error}`);
                    }
                    return urlPattern;
            }
        });
    }
}
exports.NetworkProcessor = NetworkProcessor;
//# sourceMappingURL=NetworkProcessor.js.map